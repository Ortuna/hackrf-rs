/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
pub type int8_t = i8;
pub type int16_t = i16;
pub type int32_t = i32;
pub type int64_t = i64;
pub type uint8_t = u8;
pub type uint16_t = u16;
pub type uint32_t = u32;
pub type uint64_t = u64;
pub type int_least8_t = int8_t;
pub type int_least16_t = int16_t;
pub type int_least32_t = int32_t;
pub type int_least64_t = int64_t;
pub type uint_least8_t = uint8_t;
pub type uint_least16_t = uint16_t;
pub type uint_least32_t = uint32_t;
pub type uint_least64_t = uint64_t;
pub type int_fast8_t = int8_t;
pub type int_fast16_t = int16_t;
pub type int_fast32_t = int32_t;
pub type int_fast64_t = int64_t;
pub type uint_fast8_t = uint8_t;
pub type uint_fast16_t = uint16_t;
pub type uint_fast32_t = uint32_t;
pub type uint_fast64_t = uint64_t;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct __mbstate_t {
    pub _bindgen_data_: [u64; 16usize],
}
impl __mbstate_t {
    pub unsafe fn __mbstate8(&mut self)
     -> *mut [::std::os::raw::c_char; 128usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _mbstateL(&mut self) -> *mut ::std::os::raw::c_longlong {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for __mbstate_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
impl ::std::default::Default for __darwin_pthread_handler_rec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
impl ::std::clone::Clone for _opaque_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for _opaque_pthread_attr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
impl ::std::clone::Clone for _opaque_pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for _opaque_pthread_cond_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
impl ::std::default::Default for _opaque_pthread_condattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
impl ::std::clone::Clone for _opaque_pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for _opaque_pthread_mutex_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
impl ::std::default::Default for _opaque_pthread_mutexattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
impl ::std::default::Default for _opaque_pthread_once_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
impl ::std::clone::Clone for _opaque_pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for _opaque_pthread_rwlock_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
impl ::std::default::Default for _opaque_pthread_rwlockattr_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
impl ::std::clone::Clone for _opaque_pthread_t {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for _opaque_pthread_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intptr_t = isize;
pub type uintptr_t = usize;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[derive(Copy, Clone)]
#[repr(i32)]
#[derive(Debug)]
pub enum hackrf_error {
    HACKRF_SUCCESS = 0,
    HACKRF_TRUE = 1,
    HACKRF_ERROR_INVALID_PARAM = -2,
    HACKRF_ERROR_NOT_FOUND = -5,
    HACKRF_ERROR_BUSY = -6,
    HACKRF_ERROR_NO_MEM = -11,
    HACKRF_ERROR_LIBUSB = -1000,
    HACKRF_ERROR_THREAD = -1001,
    HACKRF_ERROR_STREAMING_THREAD_ERR = -1002,
    HACKRF_ERROR_STREAMING_STOPPED = -1003,
    HACKRF_ERROR_STREAMING_EXIT_CALLED = -1004,
    HACKRF_ERROR_OTHER = -9999,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum hackrf_board_id {
    BOARD_ID_JELLYBEAN = 0,
    BOARD_ID_JAWBREAKER = 1,
    BOARD_ID_HACKRF_ONE = 2,
    BOARD_ID_INVALID = 255,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum hackrf_usb_board_id {
    USB_BOARD_ID_JAWBREAKER = 24651,
    USB_BOARD_ID_HACKRF_ONE = 24713,
    USB_BOARD_ID_RAD1O = 52245,
    USB_BOARD_ID_INVALID = 65535,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum rf_path_filter {
    RF_PATH_FILTER_BYPASS = 0,
    RF_PATH_FILTER_LOW_PASS = 1,
    RF_PATH_FILTER_HIGH_PASS = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum transceiver_mode_t {
    TRANSCEIVER_MODE_OFF = 0,
    TRANSCEIVER_MODE_RX = 1,
    TRANSCEIVER_MODE_TX = 2,
    TRANSCEIVER_MODE_SS = 3,
    TRANSCEIVER_MODE_CPLD_UPDATE = 4,
}
pub enum hackrf_device { }
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct hackrf_transfer {
    pub device: *mut hackrf_device,
    pub buffer: *mut uint8_t,
    pub buffer_length: ::std::os::raw::c_int,
    pub valid_length: ::std::os::raw::c_int,
    pub rx_ctx: *mut ::std::os::raw::c_void,
    pub tx_ctx: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for hackrf_transfer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct read_partid_serialno_t {
    pub part_id: [uint32_t; 2usize],
    pub serial_no: [uint32_t; 4usize],
}
impl ::std::default::Default for read_partid_serialno_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct hackrf_device_list {
    pub serial_numbers: *mut *mut ::std::os::raw::c_char,
    pub usb_board_ids: *mut hackrf_usb_board_id,
    pub usb_device_index: *mut ::std::os::raw::c_int,
    pub devicecount: ::std::os::raw::c_int,
    pub usb_devices: *mut *mut ::std::os::raw::c_void,
    pub usb_devicecount: ::std::os::raw::c_int,
}
impl ::std::default::Default for hackrf_device_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type hackrf_device_list_t = hackrf_device_list;
pub type hackrf_sample_block_cb_fn =
    ::std::option::Option<unsafe extern "C" fn(transfer: *mut hackrf_transfer)
                              -> ::std::os::raw::c_int>;
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl ::std::default::Default for __va_list_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[link(name = "hackrf", kind = "dylib")]
extern "C" {
    pub fn hackrf_init() -> ::std::os::raw::c_int;
    pub fn hackrf_exit() -> ::std::os::raw::c_int;
    pub fn hackrf_device_list() -> *mut hackrf_device_list_t;
    pub fn hackrf_device_list_open(list: *mut hackrf_device_list_t,
                                   idx: ::std::os::raw::c_int,
                                   device: *mut *mut hackrf_device)
     -> ::std::os::raw::c_int;
    pub fn hackrf_device_list_free(list: *mut hackrf_device_list_t);
    pub fn hackrf_open(device: *mut *mut hackrf_device)
     -> ::std::os::raw::c_int;
    pub fn hackrf_open_by_serial(desired_serial_number:
                                     *const ::std::os::raw::c_char,
                                 device: *mut *mut hackrf_device)
     -> ::std::os::raw::c_int;
    pub fn hackrf_close(device: *mut hackrf_device) -> ::std::os::raw::c_int;
    pub fn hackrf_start_rx(device: *mut hackrf_device,
                           callback: hackrf_sample_block_cb_fn,
                           rx_ctx: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn hackrf_stop_rx(device: *mut hackrf_device)
     -> ::std::os::raw::c_int;
    pub fn hackrf_start_tx(device: *mut hackrf_device,
                           callback: hackrf_sample_block_cb_fn,
                           tx_ctx: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
    pub fn hackrf_stop_tx(device: *mut hackrf_device)
     -> ::std::os::raw::c_int;
    pub fn hackrf_is_streaming(device: *mut hackrf_device)
     -> ::std::os::raw::c_int;
    pub fn hackrf_max2837_read(device: *mut hackrf_device,
                               register_number: uint8_t, value: *mut uint16_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_max2837_write(device: *mut hackrf_device,
                                register_number: uint8_t, value: uint16_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_si5351c_read(device: *mut hackrf_device,
                               register_number: uint16_t,
                               value: *mut uint16_t) -> ::std::os::raw::c_int;
    pub fn hackrf_si5351c_write(device: *mut hackrf_device,
                                register_number: uint16_t, value: uint16_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_set_baseband_filter_bandwidth(device: *mut hackrf_device,
                                                bandwidth_hz: uint32_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_rffc5071_read(device: *mut hackrf_device,
                                register_number: uint8_t,
                                value: *mut uint16_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_rffc5071_write(device: *mut hackrf_device,
                                 register_number: uint8_t, value: uint16_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_spiflash_erase(device: *mut hackrf_device)
     -> ::std::os::raw::c_int;
    pub fn hackrf_spiflash_write(device: *mut hackrf_device,
                                 address: uint32_t, length: uint16_t,
                                 data: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
    pub fn hackrf_spiflash_read(device: *mut hackrf_device, address: uint32_t,
                                length: uint16_t,
                                data: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
    pub fn hackrf_cpld_write(device: *mut hackrf_device,
                             data: *mut ::std::os::raw::c_uchar,
                             total_length: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
    pub fn hackrf_board_id_read(device: *mut hackrf_device,
                                value: *mut uint8_t) -> ::std::os::raw::c_int;
    pub fn hackrf_version_string_read(device: *mut hackrf_device,
                                      version: *mut ::std::os::raw::c_char,
                                      length: uint8_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_set_freq(device: *mut hackrf_device, freq_hz: uint64_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_set_freq_explicit(device: *mut hackrf_device,
                                    if_freq_hz: uint64_t,
                                    lo_freq_hz: uint64_t,
                                    path: rf_path_filter)
     -> ::std::os::raw::c_int;
    pub fn hackrf_set_sample_rate_manual(device: *mut hackrf_device,
                                         freq_hz: uint32_t, divider: uint32_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_set_sample_rate(device: *mut hackrf_device, freq_hz: f64)
     -> ::std::os::raw::c_int;
    pub fn hackrf_set_amp_enable(device: *mut hackrf_device, value: uint8_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_board_partid_serialno_read(device: *mut hackrf_device,
                                             read_partid_serialno:
                                                 *mut read_partid_serialno_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_set_lna_gain(device: *mut hackrf_device, value: uint32_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_set_vga_gain(device: *mut hackrf_device, value: uint32_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_set_txvga_gain(device: *mut hackrf_device, value: uint32_t)
     -> ::std::os::raw::c_int;
    pub fn hackrf_set_antenna_enable(device: *mut hackrf_device,
                                     value: uint8_t) -> ::std::os::raw::c_int;
    pub fn hackrf_error_name(errcode: hackrf_error)
     -> *const ::std::os::raw::c_char;
    pub fn hackrf_board_id_name(board_id: hackrf_board_id)
     -> *const ::std::os::raw::c_char;
    pub fn hackrf_usb_board_id_name(usb_board_id: hackrf_usb_board_id)
     -> *const ::std::os::raw::c_char;
    pub fn hackrf_filter_path_name(path: rf_path_filter)
     -> *const ::std::os::raw::c_char;
    pub fn hackrf_compute_baseband_filter_bw_round_down_lt(bandwidth_hz:
                                                               uint32_t)
     -> uint32_t;
    pub fn hackrf_compute_baseband_filter_bw(bandwidth_hz: uint32_t)
     -> uint32_t;
}
